#!/usr/bin/env ruby
# This can live with being in ruby because it's highly unlikely I'd be
# trying to get into checkouts on a system without that installed.

############################################################
# Config

checkout_patterns = ENV['CHECKOUTS'] || %w[ /home/cjs/co/* ].join(':')

ENV['CHECKOUTS'] || File.exist?('/u/cjs/co') &&
    $stderr.puts("WARNING: /u/cjs/co should not exist")

############################################################
# Functions

class String
    def fsplit; split(File::Separator); end
end
module Enumerable
    def take_while
        inject([]) { |memo, el| yield(el) ? (memo << el) : (return memo) }
    end
end

def exit_with(user_message, value_to_shell = user_message)
    $stderr.puts(user_message)
    $stdout.puts(value_to_shell)
    exit
end

def svn_version
    ver=`svn -q --version 2>/dev/null`
    return "NO-SVN" unless $?.success?
    m = ver.match(/^(\d+)\.(\d+)\./)
    m[1] + m[2]
end

############################################################
# Main

case ARGV[0]
    when '-c' then	mode = :cd;   		ARGV.shift
    when '-1' then	mode = :list_first;	ARGV.shift
    else		mode = :list
end

mode == :cd && ARGV[0].nil? && exit_with('/home/cjs/co')

checkout_dir = /^#{ARGV.shift.gsub(/\.([^*])/, '.*\1')}/
checkout_subdirs = ARGV.collect { |d| d + '*' }

checkouts = checkout_patterns.
    gsub(/VER/, svn_version).
    split(':').
    collect { |pattern| Dir[pattern].sort }.flatten.uniq
checkouts.empty? && (
    $stderr.puts(
	"Can't find any checkouts matching #{checkout_dir.inspect} in\n  " +
	checkout_patterns.split(':').join("\n  "))
    exit 1
    )

matching_checkouts = checkouts.select {
    |co| File.basename(co).match(checkout_dir) }
matching_subdirs = matching_checkouts.
    collect { |co| Dir[File.join(co, *checkout_subdirs)] }.
    flatten.
    select { |f| File.directory?(f) }

# It used to be convenient to print out the directories the longest common
# component removed from the front, but that's just / these days so seems
# a bit pointless. Thus, the following paragraph is unused.
common_prefix = File.join(checkouts.inject(checkouts[0].fsplit) {
    |memo, path|
    memo.zip(path.fsplit).take_while { |a,b| a==b }.collect { |a,b| a } })
without_bases = matching_subdirs.
    collect { |d| d.sub(common_prefix + '/', '') }

case mode
when :list then
    puts(matching_subdirs.join("\n"))
when :list_first then
    puts(matching_subdirs[0])
when :cd  then
    case matching_subdirs.length
    when 0 then
	$stderr.puts("No checkout found for #{ARGV[0].inspect}")
	exit(1)
    when 1 then
	exit_with(matching_subdirs[0])
    else
	exit_with("Changing to first of:\n  #{matching_subdirs.join("\n  ")}",
	    matching_subdirs[0])
    end
else
    fail("INTERNAL ERROR: bad mode: #{mode}")
end
